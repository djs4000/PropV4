# **agents.md (LLM-Optimized Version, v4)**

## **Purpose**

This document defines all technical constraints, hardware mappings, state logic, configuration, and development rules required for generating code for the **Digital Flame** prop. All code generated must comply with this spec.

---

# **1. System Summary**

The Digital Flame is an ESP32-based prop used in a laser-tag style game. It communicates with a backend API, reacts to state changes, plays LED/audio effects, and accepts input via keypad and buttons.

**Board:** LCDWIKI 2.8" ESP32-32E display module (ESP32-32E)

**Module:** ESP32-WROOM-32E (ESP32-D0WD-V3, Xtensa dual-core 32-bit LX6)

---

# **2. Directory + Module Structure**

All autogenerated code MUST follow this structure unless explicitly instructed otherwise:

```text
/src
  main.cpp
  state_machine.cpp / state_machine.h
  network.cpp / network.h
  inputs.cpp / inputs.h
  effects.cpp / effects.h      (LED + audio)
  ui.cpp / ui.h                (TFT + touch + web UI handlers)
  util.cpp / util.h
/include
  wifi_config.h                (default WiFi)
  game_config.h                (default gameplay config)
```

### Module Responsibilities

**state\_machine:**

- Holds enum definitions.
- Runs transitions.
- Exposes: `updateState()`, `getState()`, `setState()`.

**network:**

- WiFi connect/reconnect.
- Periodic POST to endpoint.
- Parse JSON response.
- Maintain `lastSuccessfulApiMs` timestamp (only updated on valid 200 + parsed JSON).
- Non-blocking.

**inputs:**

- Keypad scanning (PCF8574 @ 0x20).
- Two buttons (PCF8574 @ 0x21).
- Long-press detection (3s by default).
- Expose callbacks or polled functions.

**effects:**

- LED strip (WS2812B on pin 19).
- Audio tone playback via DAC/amp.
- All animations non-blocking.

**ui:**

- TFT drawing (TFT\_eSPI).
- Touch input (XPT2046).
- Display current state, timer, error/connection status.
- Expose simple web UI for configuration (defuse code, detonation time, possibly endpoint).

**util:**

- Helper functions (string↔enum mapping, timing helpers, logging helpers, etc.).

---

# **3. Hardware Pin Mapping (Authoritative)**

### **Display (ILI9341)**

- MOSI: 13
- MISO: 12
- SCK: 14
- CS: 15
- DC: 2
- Backlight: 21

### **Touch (XPT2046)**

- CS: 33
- IRQ: 36
- MOSI: 32
- MISO: 39
- SCK: 25

### **I²C Bus**

- SDA: 23
- SCL: 18
- Frequency: 100kHz
- NOTE: SD Card unavailable when using these pins.

### **PCF8574 Expanders**

**0x20 → Keypad (4x4 matrix)**

- P0–P3: Rows
- P4–P7: Columns

**0x21 → Buttons**

- P0: Button A
- P1: Button B

Buttons behave as:

- One terminal → 3.3V
- Other terminal → PCF8574 pin
- Internal weak pull-up/down ≈ required; PCF8574 uses quasi-bidirectional I/O.

### **Effects**

- LED Strip: pin **19** (WS2812B, number of LEDs configurable).
- Speaker Amplifier Enable: pin **4** (LOW = enable).
- Audio Output: pin **26**.

---

# **4. Networking Requirements**

### **POST Payload Format**

```json
{
  "state": "Ready",         // enum → string mapping: "On", "Ready", "Active", "Arming", "Armed", "Defused", "Detonated", "Error"
  "timer": 40000,           // milliseconds remaining (only active / meaningful in ARMED)
  "timestamp": 638981335320045200  // int64 ticks
}
```


Allowed `state` values in JSON:

- `"On"`, `"Ready"`, `"Active"`, `"Arming"`, `"Armed"`, `"Defused"`, `"Detonated"`, `"Error"`.

### **API Response**

```json
{
  "status": "Running",      // match status
  "remaining_time_ms": 240171,
  "timestamp": 638981335320045200
}
```

### **Transmission Rules**

- POST every **API\_POST\_INTERVAL\_MS** (default 1000 ms).
- Non-blocking.
- On individual request failure: retry silently, keep current state.
- `lastSuccessfulApiMs` is updated only when a valid 200 response is received and JSON parsed successfully.
- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) while WiFi is connected, apply the global timeout rule (see State Machine).
- WiFi reconnect automatically.

---

# **5. Enumerations (Strict)**

### **Prop States**

```cpp
enum FlameState {
  ON,
  READY,
  ACTIVE,
  ARMING,
  ARMED,
  DEFUSED,
  DETONATED,
  ERROR_STATE
};
```

`ERROR_STATE` corresponds to the `"Error"` value in JSON and the Error state in the textual state machine.

### **Match Status From API**

```cpp
enum MatchStatus {
  WaitingOnStart,
  Countdown,
  Running,
  WaitingOnFinalData,
  Completed,
  Cancelled
};
```

Mapping string ↔ enum MUST be implemented accurately. Do not invent new strings.

---

# **6. State Machine (Authoritative Logic)**

## Global networking timeout rule

From any non-error state (`ON`, `READY`, `ACTIVE`, `ARMING`, `ARMed`, `DEFUSED`, `DETONATED`):

- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) **and** WiFi is connected, transition to `ERROR_STATE`.

`lastSuccessfulApiMs` is updated only on successful API responses.

## State-by-state logic

```text
ON:
  - Boot
  - Connect to WiFi
  → READY when WiFi is connected
  → ERROR_STATE if unable to connect to WiFi after MAX_WIFI_RETRIES (default 10 attempts)

READY:
  - Poll API
  - Show idle screen
  → ACTIVE when API status == "Running"
  (Global timeout rule may transition to ERROR_STATE)

ACTIVE:
  - Match has started and attacking team is on their way to plant the prop
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  → ARMING when BOTH buttons are pressed (start arming timer)
  (Global timeout rule may transition to ERROR_STATE)

ARMING:
  - Both buttons are currently held, arming countdown in progress
  → ARMED if BOTH buttons remain pressed for ≥ BUTTON_HOLD_MS (default 3000 ms)
  → ACTIVE if either button is released before BUTTON_HOLD_MS (cancel arming)
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  (Global timeout rule may transition to ERROR_STATE)

ARMED:
  - Local bomb timer counts down
  → DEFUSED if correct keypad code entered
  → DETONATED when bomb timer hits 0
  → READY if API status is "Completed" or "Cancelled"
  (Global timeout rule may transition to ERROR_STATE)

DEFUSED:
  - Bomb successfully defused
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

DETONATED:
  - Bomb exploded
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

ERROR_STATE:
  - Show error message on UI
  - Use error LED/audio patterns (see Effects)
  → ON after holding both buttons for ≥ BUTTON_HOLD_MS (default 3000 ms)
```

**All loops must be non-blocking.**

---

# **7. Input Rules**

### **Keypad**

- Connected through PCF8574 at 0x20.
- Must scan matrix non-blocking.
- Must provide debounced key events.
- Provide a text buffer for code entry.

**Defuse code rules:**

- Code length: `DEFUSE_CODE_LENGTH` digits (default 4).
- Allowed characters: '0'–'9' only.
- On each keypress:
  - Append digit until buffer length == `DEFUSE_CODE_LENGTH`.
  - When buffer is full:
    - If it matches the configured defuse code → trigger transition to `DEFUSED`.
    - If it does not match:
      - Play short error tone.
      - Clear buffer and allow immediate retry (no lockout by default).

### **Buttons**

- PCF8574 @ 0x21.
- Must detect sustained press ≥ `BUTTON_HOLD_MS` (default 3000 ms) of **both** buttons (for ARMING and ERROR reset).
- Restart the hold timer if either button is released early.

---

# **8. LED & Audio Behavior**

### **LEDs**

- Must run on a non-blocking frame scheduler.
- Animations MUST NOT pause due to audio or network calls.
- Suggested patterns (may be refined but keep semantics):
  - `READY`: low-intensity idle glow.
  - `ACTIVE`: subtle pulsing.
  - `ARMING`: "charging up" or progress-style pattern (visually indicates arming in progress).
  - `ARMED`: urgent pulsing / countdown-style.
  - `DEFUSED`: celebratory pattern.
  - `DETONATED`: bright flash sequence, then cool-down.
  - `ERROR_STATE`: solid or slowly pulsing red (no complex patterns).

### **Audio**

- Use DAC on pin 26.
- Enable amp by setting pin 4 LOW.
- Tone playback must be non-blocking.
- Suggested behavior (may be extended):
  - Short confirmation tone when entering `ARMING` and/or `ARMED`.
  - Distinct tone when entering `DEFUSED`.
  - Distinct tone when entering `DETONATED`.
  - Single short "error" tone upon entering `ERROR_STATE`, then silence.

---

# **9. Configuration & Persistent Storage (Preferences/NVS)**

Configuration values are stored in NVS and exposed via the web UI. Defaults are provided in `game_config.h` and used on first boot or when no NVS value exists.

Required keys:

| Key                | Type   | Purpose                             |
| ------------------ | ------ | ----------------------------------- |
| `wifi_ssid`        | string | network SSID                        |
| `wifi_pass`        | string | network password                    |
| `defuse_code`      | string | numeric defuse code                 |
| `bomb_duration_ms` | int32  | bomb countdown duration in ms       |
| `api_endpoint`     | string | API base URL/path (optional/config) |

Defaults come from `/include/wifi_config.h` (WiFi) and `/include/game_config.h` (gameplay).

The web UI must allow:

- Viewing and updating `defuse_code`.
- Viewing and updating `bomb_duration_ms`.
- Optionally updating `api_endpoint`.

---

# **10. Config Constants (Recommended)**

These should be defined (with defaults) in `game_config.h` and/or a central config header, and used throughout instead of magic numbers:

```cpp
constexpr uint32_t API_POST_INTERVAL_MS = 1000;      // 1s
constexpr uint32_t API_TIMEOUT_MS       = 10000;     // 10s
constexpr uint32_t BUTTON_HOLD_MS       = 3000;      // 3s for arming/reset
constexpr uint8_t  DEFUSE_CODE_LENGTH   = 4;         // digits
constexpr uint8_t  MAX_WIFI_RETRIES     = 10;        // attempts

// Default bomb duration (can be overridden by NVS/web UI)
constexpr uint32_t DEFAULT_BOMB_DURATION_MS = 40000; // example: 40s
```

The code must read the runtime values (defuse code, bomb duration) from Preferences/NVS, falling back to these defaults if not present.

---

# **11. Concurrency & Loop Style**

- **Primary model:** single main loop using non-blocking code driven by `millis()`.
- Do **not** create additional FreeRTOS tasks unless explicitly requested.
- Networking, inputs, state machine updates, effects, and UI should all be serviced from the main loop via small, fast, non-blocking functions.
- If FreeRTOS tasks are ever introduced in the future, they must:
  - Be clearly named and documented.
  - Not block on network or audio operations.
  - Coordinate with the state machine via thread-safe mechanisms.

In short: prefer cooperative, non-blocking scheduling in a single loop.

---

# **12. Coding Constraints**

Code generation MUST follow:

### **Non-Blocking Only**

- No `delay()`.
- Use `millis()`-based scheduling.
- Keep per-loop operations short and bounded.

### **No assumptions**

- Do not invent new API fields.
- Do not modify pin mappings.
- Do not add new states unless asked.

### **PlatformIO conventions**

- Use `ArduinoJson` for JSON.
- Use `TFT_eSPI` (already configured via `User_Setup_Select.h`).
- Use `XPT2046_Touchscreen` library defaults unless explicitly adjusted.

### **Debug Logging**

- Use `Serial` at 115200.
- Log every state transition as: `STATE: <old> -> <new>` when `DEBUG` is enabled.
- Log network failures and timeout triggers with timestamps.
- Wrap logs in `#ifdef DEBUG` / `#endif` blocks.

---

# **13. Expected Agent Behavior**

When generating code, the LLM agent MUST:

- Keep modules separated by responsibility.
- Use enums for states, not raw string comparisons.
- Generate maintainable, commented code.
- Use non-blocking patterns everywhere.
- Respect POST cadence and timeout rules.
- Maintain continuous LED animations.
- Avoid memory-heavy operations.
- Ensure correct PCF8574 handling (quasi-bidirectional).
- Implement and respect the global API timeout rule.
- Load and persist configuration values correctly (NVS + defaults).
- Send the correct JSON `state` strings, including `"Arming"` when in the ARMING state.

