<!-- OPENSPEC:START -->
# OpenSpec Instructions

These instructions are for AI assistants working in this project.

Always open `@/openspec/AGENTS.md` when the request:
- Mentions planning or proposals (words like proposal, spec, change, plan)
- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
- Sounds ambiguous and you need the authoritative spec before coding

Use `@/openspec/AGENTS.md` to learn:
- How to create and apply change proposals
- Spec format and conventions
- Project structure and guidelines

Keep this managed block so 'openspec update' can refresh the instructions.

<!-- OPENSPEC:END -->

# **agents.md (LLM-Optimized Version, v5)**

## **Purpose**

This document defines all technical constraints, hardware mappings, state logic, configuration, and development rules required for generating code for the **Digital Flame** prop. All code generated must comply with this spec.

---

# **1. System Summary**

The Digital Flame is an ESP32-based prop used in a laser-tag style game. It communicates with a backend API, reacts to state changes, plays LED/audio effects, and accepts input via keypad, buttons, and an IR confirmation remote.

**Board:** LCDWIKI 2.8" ESP32-32E display module (ESP32-32E)

**Module:** ESP32-WROOM-32E (ESP32-D0WD-V3, Xtensa dual-core 32-bit LX6)

---

# **2. Directory + Module Structure**

All autogenerated code MUST follow this structure unless explicitly instructed otherwise:

```text
/src
  main.cpp
  state_machine.cpp / state_machine.h
  network.cpp / network.h
  inputs.cpp / inputs.h
  effects.cpp / effects.h      (LED + audio)
  ui.cpp / ui.h                (TFT screen only)
  util.cpp / util.h
/include
  wifi_config.h                (default WiFi)
  game_config.h                (default gameplay config)
```

### Module Responsibilities

**state_machine:**

- Holds enum definitions.
- Runs transitions.
- Exposes: `updateState()`, `getState()`, `setState()`.

**network:**

- WiFi connect/reconnect.
- STA + AP config portal management.
- Periodic POST to backend API endpoint.
- Parse JSON response.
- Maintain `lastSuccessfulApiMs` timestamp (only updated on valid 200 + parsed JSON; behavior may differ in test/send-only modes but must be explicit).
- Serve a simple web configuration UI over HTTP (SSID/pass, defuse code, bomb duration, API endpoint).
- Non-blocking.

**inputs:**

- Keypad scanning (PCF8574 @ 0x20).
- Two buttons (PCF8574 @ 0x21).
- IR receiver handling (IRremote on pin 35) for arming confirmation.
- Long-press detection (3s by default) for both buttons.
- Arming progress timing (0.0–1.0).
- Defuse-code buffer management.
- Expose clean, polled helper functions; hide all PCF8574/IRremote internals.

**effects:**

- LED strip (WS2812B on pin 19).
- Audio tone playback via DAC/amp.
- All animations non-blocking.

**ui:**

- TFT drawing (TFT_eSPI) for on-device status and gameplay UI.
- Display current state, timer, connection status, error messages.
- Show arming progress bar and IR confirmation prompts.
- No touch handling (touch controller is unused in this version).

**util:**

- Helper functions (string↔enum mapping, timing helpers, logging helpers, formatting helpers like `MM:SS`, etc.).

---

# **3. Hardware Pin Mapping (Authoritative)**

### **Display (ILI9341)**

- MOSI: 13
- MISO: 12
- SCK: 14
- CS: 15
- DC: 2
- Backlight: 21

### **Touch (XPT2046)**

- CS: 33
- IRQ: 36
- MOSI: 32
- MISO: 39
- SCK: 25
- **Note:** Touch is currently unused; configuration is done via firmware defaults and the web UI.

### **I²C Bus**

- SDA: 18
- SCL: 23
- Frequency: 100kHz
- NOTE: SD Card unavailable when using these pins.

### **PCF8574 Expanders**

**0x20 → Keypad (4x4 matrix)**

- P0–P3: Rows
- P4–P7: Columns

**0x21 → Buttons**

- P0: Button A
- P1: Button B

Buttons behave as:

- One terminal → 3.3V
- Other terminal → PCF8574 pin
- Internal weak pull-up/down ≈ required; PCF8574 uses quasi-bidirectional I/O.

### **IR Receiver**

- IR input pin: **35**
- Library: **Arduino-IRremote v4.5.0** (from the official `Arduino-IRremote` package).
- Default initialization must follow the 4.5.0 API (e.g. `IrReceiver.begin(27, ENABLE_LED_FEEDBACK);`).

### **Effects**

- LED Strip: pin **19** (WS2812B, number of LEDs configurable).
- Speaker Amplifier Enable: pin **4** (LOW = enable). Enable during setup and leave enabled.
- Audio Output: pin **26**.

---

# **4. Networking Requirements**

### **POST Payload Format**

```json
{
  "state": "Ready",         // enum → string mapping: "On", "Ready", "Active", "Arming", "Armed", "Defused", "Detonated", "Error"
  "timer": 40000,           // milliseconds remaining (only active / meaningful in ARMED)
  "uptime_ms": 123456,     // monotonic millis for skew calculation
  "timestamp": 638981335320045200  // int64 ticks
}
```

Allowed `state` values in JSON:

- `"On"`, `"Ready"`, `"Active"`, `"Arming"`, `"Armed"`, `"Defused"`, `"Detonated"`, `"Error"`.

### **API Response**

```json
{
  "status": "Running",      // match status
  "remaining_time_ms": 240171,
  "timestamp": 638981335320045200
}
```

### **Transmission Rules**

- POST every **API_POST_INTERVAL_MS**.
  - Default: **500 ms in release builds**, **5000 ms in debug builds** (while cadence is finalized).
- Non-blocking.
- On individual request failure: retry silently, keep current state.
- `lastSuccessfulApiMs` is updated only when a valid 200 response is received and JSON parsed successfully:
  - Do **not** refresh it when the API is disabled.
  - In test/send-only modes, you may update it but must also surface a UI indication that calls are simulated.
- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) while WiFi is connected, apply the global timeout rule (see State Machine).
- While `ACTIVE`, missed calls should also display a small network error banner at the bottom of the UI but allow play to continue on an internal clock.
- WiFi must reconnect automatically.
- The prop must send `uptime_ms` (millis) in every packet to allow the server to calculate clock skew.

---

# **5. Enumerations (Strict)**

### **Prop States**

```cpp
enum FlameState {
  ON,
  READY,
  ACTIVE,
  ARMING,
  ARMED,
  DEFUSED,
  DETONATED,
  ERROR_STATE
};
```

`ERROR_STATE` corresponds to the `"Error"` value in JSON and the Error state in the textual state machine.

### **Match Status From API**

```cpp
enum MatchStatus {
  WaitingOnStart,
  Countdown,
  Running,
  WaitingOnFinalData,
  Completed,
  Cancelled
};
```

Mapping string ↔ enum MUST be implemented accurately. Do not invent new strings.

---

# **6. State Machine (Authoritative Logic)**

## Global networking timeout rule

From any non-error state (`ON`, `READY`, `ACTIVE`, `ARMING`, `ARMed`, `DEFUSED`, `DETONATED`):

- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) **and** WiFi is connected, transition to `ERROR_STATE`.

`lastSuccessfulApiMs` is updated only on successful API responses (no updates when API is disabled; test/send-only modes may update while flagging the UI as simulated).

## State-by-state logic

```text
ON:
  - Boot
  - Connect to WiFi
  - First API request sent after WiFi connects
  → READY after the first API response when match status is anything except "Running"
  → ACTIVE after the first API response when match status is "Running"
  → ERROR_STATE if unable to connect to WiFi after MAX_WIFI_RETRIES (default 10 attempts)

READY:
  - Poll API
  - Show idle screen
  → ACTIVE when API status == "Running"
  (Global timeout rule may transition to ERROR_STATE)

ACTIVE:
  - Match has started and attacking team is on their way to plant the prop
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  → ARMING when BOTH buttons are pressed (start arming timer)
  - If API calls are missed, keep running on the internal clock and show a small network error message at the bottom of the UI
  (Global timeout rule may transition to ERROR_STATE)

ARMING:
  - Both buttons are currently held, arming countdown in progress
  - After BOTH buttons remain pressed for ≥ BUTTON_HOLD_MS (default 3000 ms), open an IR confirmation window:
    - Show "Confirm activation" in the UI during this window
    - Listen for any IR code on pin 27 using Arduino-IRremote v4.5.0 (protocol-agnostic)
    - If an IR code is received within the confirmation window → ARMED (play confirmation beep)
    - If the confirmation window expires without IR → revert to ACTIVE
  → ACTIVE if either button is released before BUTTON_HOLD_MS (cancel arming)
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  (Global timeout rule may transition to ERROR_STATE)

ARMED:
  - Local bomb timer counts down
  → DEFUSED if correct keypad code entered
  → DETONATED when bomb timer hits 0
  → READY if API status is "Completed" or "Cancelled"
  (Global timeout rule may transition to ERROR_STATE)

DEFUSED:
  - Bomb successfully defused
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

DETONATED:
  - Bomb exploded
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

ERROR_STATE:
  - Show error message on UI
  - Use error LED/audio patterns (see Effects)
  → ON after holding both buttons for ≥ BUTTON_HOLD_MS (default 3000 ms)
```

**All loops must be non-blocking.**

### Outstanding implementation TODOs

- Add per-state LED and audio effects consistent with the behaviors above.
- Add timer logic (armed countdown and internal match timer fallback during disconnection).
- Complete ARMED countdown wiring and UI progress updates once real timers are available.
- Expand web UI with debug options (state changes, triggering lights and sounds).
- Integrate a real timestamp/telemetry source for API payloads instead of placeholder values.

---

# **7. Input Rules**

### **Keypad**

- Connected through PCF8574 at 0x20.
- Must scan matrix non-blocking.
- Must provide debounced key events.
- Provide a text buffer for code entry.

**Defuse code rules:**

- Code length: `DEFUSE_CODE_LENGTH` digits (default 4).
- Allowed characters: '0'–'9' only.
- On each keypress:
  - Append digit until buffer length == `DEFUSE_CODE_LENGTH`.
  - When buffer is full:
    - If it matches the configured defuse code → trigger transition to `DEFUSED`.
    - If it does not match:
      - Play short error tone and lock out keypad entry for the tone's duration.
      - Clear buffer and allow retry once the tone finishes.

### **Buttons**

- PCF8574 @ 0x21.
- Must detect sustained press ≥ `BUTTON_HOLD_MS` (default 3000 ms) of **both** buttons (for ARMING and ERROR reset).
- Restart the hold timer if either button is released early.

### **IR Confirmation (ARMING)**

- Use Arduino-IRremote v4.5.0 on pin 27.
- After both buttons are held for `BUTTON_HOLD_MS`, open a configurable confirmation window (default 5000 ms) that listens for any IR blast.
- Show "Confirm activation" in the UI during this window.
- If an IR code is received within the window → advance to `ARMED`.
- If the window expires without an IR code → revert to `ACTIVE`.
- IR decoding must be non-blocking; use the 4.5.0-style `IrReceiver.decode()` / `IrReceiver.resume()` loop.

---

# **8. LED & Audio Behavior**

### **LEDs**

- 14×8 matrix wrapped around a cylinder; patterns should respect the physical wrap.
- Must run on a non-blocking frame scheduler and stay active during network/audio work.
- Behaviors (high-level; timing details may be refined later):
  - **Boot/ON:** flash all LEDs at max-brightness yellow and beep once.
  - **READY:** low yellow chaser.
  - **ACTIVE:** pulsing green.
  - **ARMING:** build from the bottom up to mirror the UI progress bar; if possible, sweep a tone that pitches up during the fill and play a confirmation beep once the IR-confirmed arm completes.
  - **Pre-match freeze time (match status == `Countdown`):** beep once per second for the final 5 seconds of the countdown.
  - **ARMED:** flash red; during the last 10 seconds, beep every second, and increase to every 500 ms in the final 3 seconds.
  - **DEFUSED:** flash bright blue then fade to off.
  - **DETONATED:** flash red rapidly for 10 seconds and sustain beeping for the same duration.
  - **ERROR_STATE:** solid or slowly pulsing red (no complex patterns).
  - **Keypad:** beep on each keypress.

### **Audio**

- Use DAC on pin 26.
- Enable amp by setting pin 4 LOW.
- Tone playback must be non-blocking.
- Follow the cues listed above (boot beep, countdown beeps, arming pitch-up + confirmation, keypad clicks, armed/defused/detonated beeps, and error tone as needed).

---

# **9. Configuration & Persistent Storage (Preferences/NVS)**

Configuration values are stored in NVS and exposed via the web UI. Defaults are provided in `game_config.h` and used on first boot or when no NVS value exists.

Required keys:

| Key                | Type   | Purpose                             |
| ------------------ | ------ | ----------------------------------- |
| `wifi_ssid`        | string | network SSID                        |
| `wifi_pass`        | string | network password                    |
| `defuse_code`      | string | numeric defuse code                 |
| `bomb_duration_ms` | int32  | bomb countdown duration in ms       |
| `api_endpoint`     | string | API base URL/path (optional/config) |

Defaults come from `/include/wifi_config.h` (WiFi) and `/include/game_config.h` (gameplay).

The web UI must allow:

- Viewing and updating `defuse_code`.
- Viewing and updating `bomb_duration_ms`.
- Optionally updating `api_endpoint`.

---

# **10. Config Constants (Recommended)**

These should be defined (with defaults) in `game_config.h` and/or a central config header, and used throughout instead of magic numbers:

```cpp
constexpr uint32_t API_POST_INTERVAL_MS    = 500;   // release default; debug builds use 5000 ms while cadence is finalized
constexpr uint32_t API_TIMEOUT_MS          = 10000; // 10s
constexpr uint32_t BUTTON_HOLD_MS          = 3000;  // 3s for arming/reset
constexpr uint32_t IR_CONFIRM_WINDOW_MS    = 5000;  // default 5s IR confirmation window; should be configurable
constexpr uint8_t  DEFUSE_CODE_LENGTH      = 4;     // digits
constexpr uint8_t  MAX_WIFI_RETRIES        = 10;    // attempts

// Default bomb duration (can be overridden by NVS/web UI)
constexpr uint32_t DEFAULT_BOMB_DURATION_MS = 40000; // example: 40s
```

The code must read the runtime values (defuse code, bomb duration) from Preferences/NVS, falling back to these defaults if not present.

---

# **11. Concurrency & Loop Style**

- **Primary model:** single main loop using non-blocking code driven by `millis()`.
- Do **not** create additional FreeRTOS tasks unless explicitly requested.
- Networking, inputs, state machine updates, effects, and UI should all be serviced from the main loop via small, fast, non-blocking functions.
- If FreeRTOS tasks are ever introduced in the future, they must:
  - Be clearly named and documented.
  - Not block on network or audio operations.
  - Coordinate with the state machine via thread-safe mechanisms.

**Concurrency exception:** API networking POSTs run in a dedicated FreeRTOS task pinned to Core 0 so that blocking `HTTPClient` calls never stall the UI/effects loop on Core 1. All other modules (inputs, state machine, UI, effects, config portal) remain on the cooperative single-loop scheduler. No additional tasks are allowed without explicit instruction.

In short: prefer cooperative, non-blocking scheduling in a single loop.

---

# **12. Coding Constraints**

Code generation MUST follow:

### **Non-Blocking Only**

- No `delay()`.
- Use `millis()`-based scheduling.
- Keep per-loop operations short and bounded.

### **No assumptions**

- Do not invent new API fields.
- Do not modify pin mappings.
- Do not add new states unless asked.

### **PlatformIO conventions**

- Use `ArduinoJson` for JSON.
- Use `TFT_eSPI` (already configured via `User_Setup_Select.h`).
- Use `XPT2046_Touchscreen` only if touch is re-enabled in future revisions.
- Use **Arduino-IRremote v4.5.0** and its official API as documented at https://arduino-irremote.github.io/Arduino-IRremote/index.html.

### **Debug Logging**

- Use `Serial` at 115200.
- Log every state transition as: `STATE: <old> -> <new>` when `DEBUG` is enabled.
- Log network failures and timeout triggers with timestamps.
- Wrap logs in `#ifdef DEBUG` / `#endif` blocks.

---

# **13. Expected Agent Behavior**

When generating code, the LLM agent MUST:

- Keep modules separated by responsibility.
- Use enums for states, not raw string comparisons.
- Generate maintainable, commented code.
- Use non-blocking patterns everywhere.
- Respect POST cadence and timeout rules.
- Maintain continuous LED animations.
- Avoid memory-heavy operations.
- Ensure correct PCF8574 handling (quasi-bidirectional).
- Implement and respect the global API timeout rule.
- Load and persist configuration values correctly (NVS + defaults).
- Send the correct JSON `state` strings, including `"Arming"` when in the ARMING state.
- Use Arduino-IRremote v4.5.0 correctly for IR confirmation during the ARMING state.

