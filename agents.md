# **agents.md (LLM-Optimized Version, v4)**

## **Purpose**

This document defines all technical constraints, hardware mappings, state logic, configuration, and development rules required for generating code for the **Digital Flame** prop. All code generated must comply with this spec.

---

# **1. System Summary**

The Digital Flame is an ESP32-based prop used in a laser-tag style game. It communicates with a backend API, reacts to state changes, plays LED/audio effects, and accepts input via keypad and buttons.

**Board:** LCDWIKI 2.8" ESP32-32E display module (ESP32-32E)

**Module:** ESP32-WROOM-32E (ESP32-D0WD-V3, Xtensa dual-core 32-bit LX6)

---

# **2. Directory + Module Structure**

All autogenerated code MUST follow this structure unless explicitly instructed otherwise:

```text
/src
  main.cpp
  state_machine.cpp / state_machine.h
  network.cpp / network.h
  inputs.cpp / inputs.h
  effects.cpp / effects.h      (LED + audio)
  ui.cpp / ui.h                (TFT + web UI handlers)
  util.cpp / util.h
/include
  wifi_config.h                (default WiFi)
  game_config.h                (default gameplay config)
```

### Module Responsibilities

**state\_machine:**

- Holds enum definitions.
- Runs transitions.
- Exposes: `updateState()`, `getState()`, `setState()`.

**network:**

- WiFi connect/reconnect.
- Periodic POST to endpoint.
- Parse JSON response.
- Maintain `lastSuccessfulApiMs` timestamp (only updated on valid 200 + parsed JSON; no updates when API is disabled; test/send-only modes may update while flagging the UI).
- Non-blocking.

**inputs:**

- Keypad scanning (PCF8574 @ 0x20).
- Two buttons (PCF8574 @ 0x21).
- Long-press detection (3s by default).
- Expose callbacks or polled functions.

**effects:**

- LED strip (WS2812B on pin 19).
- Audio tone playback via DAC/amp.
- All animations non-blocking.

**ui:**

- TFT drawing (TFT\_eSPI).
- Display current state, timer, error/connection status (including network warnings).
- Expose simple web UI for configuration (defuse code, detonation time, possibly endpoint).

**util:**

- Helper functions (string↔enum mapping, timing helpers, logging helpers, etc.).

---

# **3. Hardware Pin Mapping (Authoritative)**

### **Display (ILI9341)**

- MOSI: 13
- MISO: 12
- SCK: 14
- CS: 15
- DC: 2
- Backlight: 21

### **Touch (XPT2046)**

- CS: 33
- IRQ: 36
- MOSI: 32
- MISO: 39
- SCK: 25
- Touch handling is currently unused; configuration is handled in firmware and via the web UI.

### **I²C Bus**

- SDA: 23
- SCL: 18
- Frequency: 100kHz
- NOTE: SD Card unavailable when using these pins.

### **PCF8574 Expanders**

**0x20 → Keypad (4x4 matrix)**

- P0–P3: Rows
- P4–P7: Columns

**0x21 → Buttons**

- P0: Button A
- P1: Button B

Buttons behave as:

- One terminal → 3.3V
- Other terminal → PCF8574 pin
- Internal weak pull-up/down ≈ required; PCF8574 uses quasi-bidirectional I/O.

### **IR Receiver**

- Use `IRremote` library.
- IR input pin: **27** (UART pins may be reclaimed only if explicitly reconfigured).

### **Effects**

- LED Strip: pin **19** (WS2812B, number of LEDs configurable).
- Speaker Amplifier Enable: pin **4** (LOW = enable).
- Audio Output: pin **26**.

---

# **4. Networking Requirements**

### **POST Payload Format**

```json
{
  "state": "Ready",         // enum → string mapping: "On", "Ready", "Active", "Arming", "Armed", "Defused", "Detonated", "Error"
  "timer": 40000,           // milliseconds remaining (only active / meaningful in ARMED)
  "timestamp": 638981335320045200  // int64 ticks
}
```


Allowed `state` values in JSON:

- `"On"`, `"Ready"`, `"Active"`, `"Arming"`, `"Armed"`, `"Defused"`, `"Detonated"`, `"Error"`.

### **API Response**

```json
{
  "status": "Running",      // match status
  "remaining_time_ms": 240171,
  "timestamp": 638981335320045200
}
```

### **Transmission Rules**

- POST every **API\_POST\_INTERVAL\_MS** (configurable; default 500 ms in release builds, 5000 ms in debug builds while the backend finalizes the cadence).
- Non-blocking.
- On individual request failure: retry silently, keep current state.
- `lastSuccessfulApiMs` is updated only when a valid 200 response is received and JSON parsed successfully; **do not** refresh it when the API is disabled. In test/send-only modes, keep the timestamp behavior but surface a UI warning that calls are simulated.
- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) while WiFi is connected, apply the global timeout rule (see State Machine). While ACTIVE, missed calls should also display a small network error banner at the bottom of the UI but allow play to continue on an internal clock.
- WiFi reconnect automatically.

---

# **5. Enumerations (Strict)**

### **Prop States**

```cpp
enum FlameState {
  ON,
  READY,
  ACTIVE,
  ARMING,
  ARMED,
  DEFUSED,
  DETONATED,
  ERROR_STATE
};
```

`ERROR_STATE` corresponds to the `"Error"` value in JSON and the Error state in the textual state machine.

### **Match Status From API**

```cpp
enum MatchStatus {
  WaitingOnStart,
  Countdown,
  Running,
  WaitingOnFinalData,
  Completed,
  Cancelled
};
```

Mapping string ↔ enum MUST be implemented accurately. Do not invent new strings.

---

# **6. State Machine (Authoritative Logic)**

## Global networking timeout rule

From any non-error state (`ON`, `READY`, `ACTIVE`, `ARMING`, `ARMed`, `DEFUSED`, `DETONATED`):

- If `millis() - lastSuccessfulApiMs >= API_TIMEOUT_MS` (default 10000 ms) **and** WiFi is connected, transition to `ERROR_STATE`.

`lastSuccessfulApiMs` is updated only on successful API responses (no updates in disabled mode; test/send-only modes may update while flagging the UI as simulated).

## State-by-state logic

```text
ON:
  - Boot
  - Connect to WiFi
  - First API request sent after WiFi connects
  → READY after the first API response when match status is anything except "Running"
  → ACTIVE after the first API response when match status is "Running"
  → ERROR_STATE if unable to connect to WiFi after MAX_WIFI_RETRIES (default 10 attempts)

READY:
  - Poll API
  - Show idle screen
  → ACTIVE when API status == "Running"
  (Global timeout rule may transition to ERROR_STATE)

ACTIVE:
  - Match has started and attacking team is on their way to plant the prop
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  → ARMING when BOTH buttons are pressed (start arming timer)
  - If API calls are missed, keep running on the internal clock and show a small network error message at the bottom of the UI
  (Global timeout rule may transition to ERROR_STATE)

ARMING:
  - Both buttons are currently held, arming countdown in progress
  - After BOTH buttons remain pressed for ≥ BUTTON_HOLD_MS (default 3000 ms), prompt for an IR confirmation blast
    - Show "Confirm activation" in the UI during this window
    - Listen for any IR code on pin 27 using `IRremote` (protocol-agnostic); configurable confirmation window
    - If IR blast received within the window → ARMED (confirmation beep)
    - If the window expires without IR → revert to ACTIVE
  → ACTIVE if either button is released before BUTTON_HOLD_MS (cancel arming)
  → READY if API status is "WaitingOnStart" or "Countdown" or "WaitingOnFinalData"
  (Global timeout rule may transition to ERROR_STATE)

ARMED:
  - Local bomb timer counts down
  → DEFUSED if correct keypad code entered
  → DETONATED when bomb timer hits 0
  → READY if API status is "Completed" or "Cancelled"
  (Global timeout rule may transition to ERROR_STATE)

DEFUSED:
  - Bomb successfully defused
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

DETONATED:
  - Bomb exploded
  → READY when API status == "WaitingOnStart" (API reset condition)
  (Global timeout rule may transition to ERROR_STATE)

ERROR_STATE:
  - Show error message on UI
  - Use error LED/audio patterns (see Effects)
  → ON after holding both buttons for ≥ BUTTON_HOLD_MS (default 3000 ms)
```

**All loops must be non-blocking.**

### Outstanding implementation TODOs

- Add per-state LED and audio effects consistent with the behaviors above.
- Add timer logic (armed countdown and internal match timer fallback during disconnection).
- Complete ARMED countdown wiring and UI progress updates once real timers are available.
- Expand web UI with debug options (state changes, triggering lights and sounds).
- Add IR receiver functionality for arming confirmation.

---

# **7. Input Rules**

### **Keypad**

- Connected through PCF8574 at 0x20.
- Must scan matrix non-blocking.
- Must provide debounced key events.
- Provide a text buffer for code entry.

**Defuse code rules:**

- Code length: `DEFUSE_CODE_LENGTH` digits (default 4).
- Allowed characters: '0'–'9' only.
- On each keypress:
  - Append digit until buffer length == `DEFUSE_CODE_LENGTH`.
  - When buffer is full:
    - If it matches the configured defuse code → trigger transition to `DEFUSED`.
    - If it does not match:
      - Play short error tone.
      - Clear buffer and allow immediate retry (no lockout by default).

### **Buttons**

- PCF8574 @ 0x21.
- Must detect sustained press ≥ `BUTTON_HOLD_MS` (default 3000 ms) of **both** buttons (for ARMING and ERROR reset).
- Restart the hold timer if either button is released early.

### **IR Confirmation (arming)**

- Use `IRremote` on pin 27.
- After both buttons are held for `BUTTON_HOLD_MS`, open a configurable confirmation window that listens for any IR blast.
- Show "Confirm activation" in the UI during this window; IR receipt advances to ARMED, otherwise the prop returns to ACTIVE when the window expires.

---

# **8. LED & Audio Behavior**

### **LEDs**

- 14×8 matrix wrapped around a cylinder; patterns should respect the wrap.
- Must run on a non-blocking frame scheduler and stay active during network/audio work.
- Behaviors:
  - **Boot/ON:** flash all LEDs at max-brightness yellow and beep once.
  - **READY:** low yellow chaser.
  - **ACTIVE:** pulsing green.
  - **ARMING:** build from the bottom up to mirror the UI progress bar; if possible, sweep a tone that pitches up during the fill and play a confirmation beep once the IR-confirmed arm completes.
  - **Pre-match freeze time (match status == `Countdown`):** beep once per second for the final 5 seconds of the countdown.
  - **ARMED:** flash red; during the last 10 seconds, beep every second, and increase to every 500 ms in the final 3 seconds.
  - **DEFUSED:** flash bright blue then fade to off.
  - **DETONATED:** flash red rapidly for 10 seconds and sustain beeping for the same duration.
  - **ERROR_STATE:** solid or slowly pulsing red (no complex patterns).
  - **Keypad:** beep on each keypress.

### **Audio**

- Use DAC on pin 26.
- Enable amp by setting pin 4 LOW.
- Tone playback must be non-blocking.
- Follow the cues listed above (boot beep, countdown beeps, arming pitch-up + confirmation, keypad clicks, armed/defused/detonated beeps, and error tone as needed).

---

# **9. Configuration & Persistent Storage (Preferences/NVS)**

Configuration values are stored in NVS and exposed via the web UI. Defaults are provided in `game_config.h` and used on first boot or when no NVS value exists.

Required keys:

| Key                | Type   | Purpose                             |
| ------------------ | ------ | ----------------------------------- |
| `wifi_ssid`        | string | network SSID                        |
| `wifi_pass`        | string | network password                    |
| `defuse_code`      | string | numeric defuse code                 |
| `bomb_duration_ms` | int32  | bomb countdown duration in ms       |
| `api_endpoint`     | string | API base URL/path (optional/config) |

Defaults come from `/include/wifi_config.h` (WiFi) and `/include/game_config.h` (gameplay).

The web UI must allow:

- Viewing and updating `defuse_code`.
- Viewing and updating `bomb_duration_ms`.
- Optionally updating `api_endpoint`.

---

# **10. Config Constants (Recommended)**

These should be defined (with defaults) in `game_config.h` and/or a central config header, and used throughout instead of magic numbers:

```cpp
constexpr uint32_t API_POST_INTERVAL_MS = 500;       // release default; debug builds use 5000 ms while cadence is finalized
constexpr uint32_t API_TIMEOUT_MS       = 10000;     // 10s
constexpr uint32_t BUTTON_HOLD_MS       = 3000;      // 3s for arming/reset
constexpr uint8_t  DEFUSE_CODE_LENGTH   = 4;         // digits
constexpr uint8_t  MAX_WIFI_RETRIES     = 10;        // attempts

// Default bomb duration (can be overridden by NVS/web UI)
constexpr uint32_t DEFAULT_BOMB_DURATION_MS = 40000; // example: 40s
```

The code must read the runtime values (defuse code, bomb duration) from Preferences/NVS, falling back to these defaults if not present.

---

# **11. Concurrency & Loop Style**

- **Primary model:** single main loop using non-blocking code driven by `millis()`.
- Do **not** create additional FreeRTOS tasks unless explicitly requested.
- Networking, inputs, state machine updates, effects, and UI should all be serviced from the main loop via small, fast, non-blocking functions.
- If FreeRTOS tasks are ever introduced in the future, they must:
  - Be clearly named and documented.
  - Not block on network or audio operations.
  - Coordinate with the state machine via thread-safe mechanisms.

In short: prefer cooperative, non-blocking scheduling in a single loop.

---

# **12. Coding Constraints**

Code generation MUST follow:

### **Non-Blocking Only**

- No `delay()`.
- Use `millis()`-based scheduling.
- Keep per-loop operations short and bounded.

### **No assumptions**

- Do not invent new API fields.
- Do not modify pin mappings.
- Do not add new states unless asked.

### **PlatformIO conventions**

- Use `ArduinoJson` for JSON.
- Use `TFT_eSPI` (already configured via `User_Setup_Select.h`).
- Use `XPT2046_Touchscreen` library defaults unless explicitly adjusted.

### **Debug Logging**

- Use `Serial` at 115200.
- Log every state transition as: `STATE: <old> -> <new>` when `DEBUG` is enabled.
- Log network failures and timeout triggers with timestamps.
- Wrap logs in `#ifdef DEBUG` / `#endif` blocks.

---

# **13. Expected Agent Behavior**

When generating code, the LLM agent MUST:

- Keep modules separated by responsibility.
- Use enums for states, not raw string comparisons.
- Generate maintainable, commented code.
- Use non-blocking patterns everywhere.
- Respect POST cadence and timeout rules.
- Maintain continuous LED animations.
- Avoid memory-heavy operations.
- Ensure correct PCF8574 handling (quasi-bidirectional).
- Implement and respect the global API timeout rule.
- Load and persist configuration values correctly (NVS + defaults).
- Send the correct JSON `state` strings, including `"Arming"` when in the ARMING state.

